// pendiente, quitar lutbc lutbd y apuntar a lutid lutvd ahorramos rom
// 20191228 lutntc menos de 256 entradas
// 20191226 lutbc 1dido
// 20191221 cambio LUTBC VMPT
// 20191220 contador actividad
// 20191216 ajusto lut
// 20191214 concurrencia acceso adc

#define VDCDC 4900

////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifdef TESTSENSOR
#include <stdio.h>
#include <math.h>
#include "tlm1.h"
void sensor(void);
void sensoracc(void);
void sensor0(void);
int main(void)
{
clock    =888;
adc[0]   =92;
adc[1]   =831;
adc[31]  =228;
adc[3]   =868;
adc[23]  =80;  //bateria
sensor0();
sensor();
printf("tba raw:%d phy:%d-30=%doC\n",adc[23],tba,tba-30);
sensoracc();
for(int n=0;n!=STATSN;n++)printf("pp:%6d pn:%6d ac:%6ld\n",stats[n].pp,stats[n].pn,stats[n].ac);
return 0;
}
#endif
////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//!! adc[3]=876 vmpt:6 0x   6 bits:-YZ
//u16 _lutdac3[]={200,332,445,540,679,775,887,982};
u16   _lutdac3[]={176,307,410,497,626,714,817,905};
u16 lutdac3(u16 v)
{
u16 n=0,m=9;
int dif,min=999;
for(n=0;n!=8;n++)
    {
    dif=abs(v-_lutdac3[n]);
    if(dif<min){m=n;min=dif;}
    }
return m;
}



#define IDDELTA 20E-6 //20uA
#define VDDELTA  1E-3 //01mV
const u16 lutid[]={65535,62079,58805,55704,52766,49983,47347,44851,42485,40245,38122,36112,34207,32403,30695,29076,27542,26090,24714,23411,22176,21007,19899,18849,17855,16914,16022,15177,14376,13618,12900,12220,11575,10965,10387,9839,9320,8828,8363,7922,7504,7108,6733,6378,6042,5723,5422,5136,4865,4608,4365,4135,3917,3710,3515,3329,3154,2987,2830,2681,2539,2405,2279,2158,2045,1937,1835,1738,1646,1559,1477,1399,1325,1256,1189,1127,1067,1011,958,907,859,814,771,730,692,655,621,588,557,528,500,473,449,425,402,381,361,342,324,307,291,275,261,247,234,222,210,199,188,179,169,160,152,144,136,129,122,116,110,104,98,93,88,84,79,75,71,67,64,60,57,54,51,49,46,44,41,39,37,35,33,32,30,28,27,25,24,23,22,20,19,18,17,16,16,15,14,13,13,12,11,11,10,10,9,9,8,8,7,7,7,6,6,6,5,5,5,4,4,4,4,4,3,3,3,3,3,3,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,0};
const u16 lutvd[]={377,375,373,371,369,368,366,364,362,360,358,356,354,352,350,348,346,344,343,341,339,337,335,333,331,329,327,325,323,321,319,318,316,314,312,310,308,306,304,302,300,298,296,294,293,291,289,287,285,283,281,279,277,275,273,271,270,268,266,264,262,260,258,256,254,252,250,248,246,245,243,241,239,237,235,233,231,229,227,225,223,221,220,218,216,214,212,210,208,206,204,202,200,198,197,195,193,191,189,187,185,183,181,179,177,176,174,172,170,168,166,164,162,160,158,157,155,153,151,149,147,145,143,141,139,138,136,134,132,130,128,126,124,123,121,119,117,115,113,112,110,108,106,104,102,101,99,97,95,93,92,90,88,86,85,83,81,79,78,76,74,73,71,69,68,66,64,63,61,60,58,57,55,53,52,51,49,48,46,45,43,42,41,39,38,37,36,35,33,32,31,30,29,28,27,26,25,24,23,22,21,20,19,19,18,0};
//paso milivoltios, retorno corriente en saltos de 20uA
//recorro el array, el ultimo elemento esta marcado con un cero
u16 lutdiode(u16 v)
{
u16 n=0;
while (lutvd[n]&&
       lutvd[n]>v)n++;  
return lutid[n];
}


//un diodo
const u16 lutbdi[]={65535,62079,58805,55704,52766,49983,47347,44851,42485,40245,38122,36112,34207,32403,30695,29076,27542,26090,24714,23411,22176,21007,19899,18849,17855,16914,16022,15177,14376,13618,12900,12220,11575,10965,10387,9839,9320,8828,8363,7922,7504,7108,6733,6378,6042,5723,5422,5136,4865,4608,4365,4135,3917,3710,3515,3329,3154,2987,2830,2681,2539,2405,2279,2158,2045,1937,1835,1738,1646,1559,1477,1399,1325,1256,1189,1127,1067,1011,958,907,859,814,771,730,692,655,621,588,557,528,500,473,449,425,402,381,361,342,324,307,291,275,261,247,234,222,210,199,188,179,169,160,152,144,136,129,122,116,110,104,98,93,88,84,79,75,71,67,64,60,57,54,51,49,46,44,41,39,37,35,33,32,30,28,27,25,24,23,22,20,19,18,17,16,16,15,14,13,13,12,11,11,10,10,9,9,8,8,7,7,7,6,6,6,5,5,5,4,4,4,4,4,3,3,3,3,3,3,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,0};
const u16 lutbdv[]={377,375,373,371,369,368,366,364,362,360,358,356,354,352,350,348,346,344,343,341,339,337,335,333,331,329,327,325,323,321,319,318,316,314,312,310,308,306,304,302,300,298,296,294,293,291,289,287,285,283,281,279,277,275,273,271,270,268,266,264,262,260,258,256,254,252,250,248,246,245,243,241,239,237,235,233,231,229,227,225,223,221,220,218,216,214,212,210,208,206,204,202,200,198,197,195,193,191,189,187,185,183,181,179,177,176,174,172,170,168,166,164,162,160,158,157,155,153,151,149,147,145,143,141,139,138,136,134,132,130,128,126,124,123,121,119,117,115,113,112,110,108,106,104,102,101,99,97,95,93,92,90,88,86,85,83,81,79,78,76,74,73,71,69,68,66,64,63,61,60,58,57,55,53,52,51,49,48,46,45,43,42,41,39,38,37,36,35,33,32,31,30,29,28,27,26,25,24,23,22,21,20,19,19,18,0};
u16 lutbd(u16 v)
{
u16 n=0;
while (lutbdv[n]&&
       lutbdv[n]>v)n++;  
return lutbdi[n];
}


//diodo+39R//39R//24R
//const u16 lutbci[]={5000,4866,4736,4610,4487,4367,4250,4136,4026,3918,3813,3712,3612,3516,3422,3330,3241,3155,3070,2988,2909,2831,2755,2682,2610,2540,2472,2406,2342,2279,2218,2159,2101,2045,1991,1937,1886,1835,1786,1738,1692,1647,1603,1560,1518,1478,1438,1400,1362,1326,1290,1256,1222,1190,1158,1127,1097,1068,1039,1011,984,958,932,907,883,860,837,814,792,771,751,731,711,692,674,656,638,621,604,588,573,557,542,528,514,500,487,474,461,449,437,425,414,403,392,381,371,361,352,342,333,324,315,307,299,291,283,276,268,261,254,247,241,234,228,222,216,210,205,199,194,189,184,179,174,169,165,160,156,152,148,144,140,136,133,129,126,122,119,116,113,110,107,104,101,98,96,93,91,88,86,84,81,79,77,75,73,71,69,67,66,64,62,60,59,57,56,54,53,51,50,49,47,46,45,44,42,41,40,39,38,37,36,35,34,33,32,32,31,30,29,28,28,27,26,25,25,24,23,23,22,22,21,20,20,19,19,18,18,17,17,16,16,16,15,15,14,14,14,13,13,13,12,12,12,11,11,11,10,10,10,10,9,9,9,9,8,8,8,8,8,7,7,7,7,7,6,6,6,6,6,6,5,5,5,5,0};
//const u16 lutbcv[]={1362,1332,1303,1275,1247,1221,1195,1169,1144,1120,1097,1074,1052,1030,1009,988,968,948,929,911,892,875,858,841,824,808,793,778,763,748,734,721,707,694,681,669,657,645,634,622,611,601,590,580,570,561,551,542,533,524,515,507,499,491,483,476,468,461,454,447,440,433,427,421,414,408,402,397,391,386,380,375,370,365,360,355,350,346,341,337,332,328,324,320,316,312,308,304,301,297,293,290,287,283,280,277,274,270,267,264,262,259,256,253,250,248,245,242,240,237,235,233,230,228,226,223,221,219,217,215,212,210,208,206,204,202,201,199,197,195,193,191,189,188,186,184,183,181,179,178,176,174,173,171,170,168,167,165,164,162,161,159,158,157,155,154,152,151,150,148,147,146,144,143,142,141,139,138,137,136,134,133,132,131,129,128,127,126,125,124,122,121,120,119,118,117,116,115,114,112,111,110,109,108,107,106,105,104,103,102,101,100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,85,84,83,82,81,80,79,79,78,77,76,75,74,73,72,71,70,70,69,68,67,66,65,64,64,63,62,61,60,59,59,58,57,56,55,55,54,53,52,52,0};
//diodosolo
const u16 lutbci[]={5000,4866,4736,4610,4487,4367,4250,4136,4026,3918,3813,3712,3612,3516,3422,3330,3241,3155,3070,2988,2909,2831,2755,2682,2610,2540,2472,2406,2342,2279,2218,2159,2101,2045,1991,1937,1886,1835,1786,1738,1692,1647,1603,1560,1518,1478,1438,1400,1362,1326,1290,1256,1222,1190,1158,1127,1097,1068,1039,1011,984,958,932,907,883,860,837,814,792,771,751,731,711,692,674,656,638,621,604,588,573,557,542,528,514,500,487,474,461,449,437,425,414,403,392,381,371,361,352,342,333,324,315,307,299,291,283,276,268,261,254,247,241,234,228,222,216,210,205,199,194,189,184,179,174,169,165,160,156,152,148,144,140,136,133,129,126,122,119,116,113,110,107,104,101,98,96,93,91,88,86,84,81,79,77,75,73,71,69,67,66,64,62,60,59,57,56,54,53,51,50,49,47,46,45,44,42,41,40,39,38,37,36,35,34,33,32,32,31,30,29,28,28,27,26,25,25,24,23,23,22,22,21,20,20,19,19,18,18,17,17,16,16,16,15,15,14,14,14,13,13,13,12,12,12,11,11,11,10,10,10,10,9,9,9,9,8,8,8,8,8,7,7,7,7,7,6,6,6,6,6,6,5,5,5,5,0};
const u16 lutbcv[]={286,285,284,283,282,281,280,279,278,277,276,275,274,273,272,271,270,270,269,268,267,266,265,264,263,262,261,260,259,258,257,256,255,254,253,252,251,250,249,248,247,246,246,245,244,243,242,241,240,239,238,237,236,235,234,233,232,231,230,229,228,227,226,225,224,223,222,222,221,220,219,218,217,216,215,214,213,212,211,210,209,208,207,206,205,204,203,202,201,200,199,199,198,197,196,195,194,193,192,191,190,189,188,187,186,185,184,183,182,181,180,179,178,177,177,176,175,174,173,172,171,170,169,168,167,166,165,164,163,162,161,160,159,158,157,157,156,155,154,153,152,151,150,149,148,147,146,145,144,143,142,141,140,139,139,138,137,136,135,134,133,132,131,130,129,128,127,126,125,124,124,123,122,121,120,119,118,117,116,115,114,113,112,112,111,110,109,108,107,106,105,104,103,102,101,101,100,99,98,97,96,95,94,93,92,92,91,90,89,88,87,86,85,85,84,83,82,81,80,79,79,78,77,76,75,74,73,73,72,71,70,69,68,68,67,66,65,64,64,63,62,61,60,60,59,58,57,57,56,55,54,53,53,52,51,51,0};
u16 lutbc(u16 v)
{
u16 n=0;
while (lutbcv[n]&&
       lutbcv[n]>v)n++;  
return lutbci[n];
}

#define NTCMINT -30
//28-Dec-2019
const u16 lutntcx[]={847,826,807,787,768,750,732,714,697,680,664,647,632,616,601,587,573,559,545,532,519,506,494,482,470,459,448,437,427,416,406,397,387,378,369,360,351,343,335,327,319,311,304,297,290,283,276,270,264,258,252,246,240,234,229,224,219,214,209,204,199,195,190,186,182,178,174,170,166,162,159,155,152,149,145,142,139,136,133,130,127,125,122,119,117,114,112,110,107,105,103,101,99,97,95,93,91,89,87,85,83,82,80,78,77,75,74,72,71,70,68,67,66,64,63,62,61,59,58,57,56,55,54,53,52,51,50,49,48,47,46,45,45,44,43,42,41,41,40,39,38,38,37,36,36,35,35,34,33,33,32,32,31,31,30,29,29,28,28,28,27,27,26,26,25,25,24,24,24,23,23,22,22,22,21,21,21,20,20,20,19,19,19,18,18,18,18,17,17,17,17,16,16,16,16,15,15,15,15,14,14,14,14,14,13,13,13,13,13,12,12,12,12,12,11,11,11,11,11,11,11,10,10,10,10,10,10,10,9,9,9,9,9,9,9,9,8,8,8,8,8,8,8,8,8,7,7,7,7,7,7,0};
u8 lutntc(u16 v)
{
u8 n=0;
while(lutntcx[n]&&
      lutntcx[n]>v)n++;  
return n;
}


//acumulo cada "10segundos"
void sensoracc(void)
{
/*
#ifdef SENSORLOCAL
//static int t0=0;if(lclock-t0<5)return;t0=lclock;printf("++ SENSORACC %ld %ld\n",lclock,lclock-t0);
for(int n=0;n!=STATSN;n++)
	{
	u16 v=*(statsv[n]);
	stats[n].ac+=v;
	}
for(int n=0;n!=BITFLIP;n++)if(bitflip[n])alarmas|=ALRMRAMERR;
if(vbus>vbat)
	{
	if(vmpt&0x0200)mptx++;
	if(vmpt&0x0100)mpty++;
	if(vmpt&0x0080)mptz++;
	if(vmpt&0x0380)mptxyz++;
	}
#endif
*/
}

	
//al arrancar el programa, 
//cada 24horas (cada 15 vueltas)
//pongo a cero 
void sensor0(void)
{
int n;
printf("++ SENSOR0\n");
for(n=0;n!=STATSN;n++){stats[n].pp=0;stats[n].pn=0xffff;stats[n].ac=0;}
mptx=0;
mpty=0;
mptz=0;
mptxyz=0;
alarmas=0;
for(n=0;n!=BITFLIP;n++)bitflip[n]=0;
}


//controlo concurrencia adc[x]
u8 semaforoadc;
u16 readadc(u8 x) 
{
u16 y;
semaforoadc=x; //operacion atomica
y=adc[x];
semaforoadc=0; //operacion atomica
return y;
}

//#define pi 3.1415
void sensor(void)
{
u32 x;
u16 adc31;
//tensiones 

x=readadc(0);x*=65535;x/=11818;vbat=(u16)x; //5.5455
x=readadc(1);x*=65535;x/=11818;vbus=(u16)x; //5.5455 

adc31=readadc(31);
if(adc31){x=1024*1024;vcpu=x/adc31;}else {adc31=1024;vcpu=4096;alarmas|=ALRMDIV0;}
printf("!! adc[31]=%d vcpu=%d\n",adc[31],vcpu);

//PRESENTACION pk+ pk- SOLO EN TIERRA
x=adcpp[0 ];x*=65535;x/=11818;stats[15].pp=(u16)x; //5.5455
x=adcpn[0 ];x*=65535;x/=11818;stats[15].pn=(u16)x; //5.5455
x=adcpp[1 ];x*=65535;x/=11818;stats[16].pp=(u16)x; //5.5455
x=adcpn[1 ];x*=65535;x/=11818;stats[16].pn=(u16)x; //5.5455
x=adcpp[31];if(x)stats[17].pp=(1024L*1024)/x;
x=adcpn[31];if(x)stats[17].pn=(1024L*1024)/x;
//

x=readadc(24);x*=adc31;x*=4;x/=1024;ttx=lutntc((u16)x);
x=readadc(19);x*=adc31;x*=4;x/=1024;trx=lutntc((u16)x);
x=readadc(23);x*=adc31;x*=4;x/=1024;tba=lutntc((u16)x);
x=readadc(16);x*=adc31;x*=4;x/=1024;txp=lutntc((u16)x);
x=readadc(17);x*=adc31;x*=4;x/=1024;txn=lutntc((u16)x);
x=readadc(18);x*=adc31;x*=4;x/=1024;typ=lutntc((u16)x);
x=readadc(27);x*=adc31;x*=4;x/=1024;tyn=lutntc((u16)x);
x=readadc(26);x*=adc31;x*=4;x/=1024;tzp=lutntc((u16)x);
x=readadc(25);x*=adc31;x*=4;x/=1024;tzn=lutntc((u16)x);

//corriente generada por las dos tiras
//si esta en circuito abierto... la considero cero
x=adc[12];if(x>1023-10)x=0;ixp=lutdiode(x)*2;
x=adc[10];if(x>1023-10)x=0;ixn=lutdiode(x)*2;
x=adc[8 ];if(x>1023-10)x=0;iyp=lutdiode(x)*2;
x=adc[9 ];if(x>1023-10)x=0;iyn=lutdiode(x)*2;
x=adc[11];if(x>1023-10)x=0;izp=lutdiode(x)*2;
x=adc[13];if(x>1023-10)x=0;izn=lutdiode(x)*2;

ibatn=0;
ibatp=0;
if(vbat>vbus)
	{
	ibatn=0;ibatp=lutbd(vbat-vbus);
	printf("!! ECLIPSE ibatp_uA:%d vbat:%d > vbus:%d diff:%d\n",ibatp*20,vbat,vbus,vbat-vbus);
	}
if(vbus>vbat)
	{
	ibatp=0;
	if(bate==1)
		ibatn=lutbc(vbus-vbat);
	else 
		{
		ibatn=0;
		printf("!! detectada condicion fin carga bateria\n");
		}
	}

x=readadc(3);vmpt=lutdac3(x);
printf("!! adc[3]=%d vmpt:%d 0x%4x bits:",readadc(3),vmpt,vmpt);
if(vmpt&0x01)printf("X"  );else printf("-"  );
if(vmpt&0x02)printf("Y"  );else printf("-"  );
if(vmpt&0x04)printf("Z\n");else printf("-\n");

//TECNICA1
if(vbus>vbat)
	{	
	if(vmpt&0x01)ix=lutdiode((VDCDC-vbus)/2);
	if(vmpt&0x02)iy=lutdiode((VDCDC-vbus)/2);
	if(vmpt&0x04)iz=lutdiode((VDCDC-vbus)/2);
	alarmas|=ALRMSOL;
	}
else 
	{
	ix=iy=iz=0;
	alarmas&=~ALRMSOL; //X or Y or Z  //!!UC satelite al sol/sombra
	}
printf("\n");

//TECNICA2
//float f,i1,p;
//alfax=999,alfay=999,alfaz=999;
//i1=ixp+ixn;f=i1/(ixm*1000/20);p=pxm*f;ix=p*50000/VDCDC;if(f)alfax=acos(f)/pi*180;
//i1=iyp+iyn;f=i1/(iym*1000/20);p=pym*f;iy=p*50000/VDCDC;if(f)alfay=acos(f)/pi*180;
//i1=izp+izn;f=i1/(izm*1000/20);p=pzm*f;iz=p*50000/VDCDC;if(f)alfaz=acos(f)/pi*180;

isolar=ix+iy+iz;
ibus  =isolar+ibatp;
pbatp =ibatp*vbat;   pbatp/=50;
psolar=isolar*VDCDC; psolar/=50;
pbus  =ibus*vbus;    pbus/=50;

/*
#ifdef SENSORLOCAL
//se ejecuta local, pero es machacada por los datos que llegan remotamente
for(int n=0;n!=STATSN;n++)
	{
	u16 v=*(statsv[n]);
	stats[n].pp=MAX(stats[n].pp,v);
	stats[n].pn=MIN(stats[n].pn,v);
	}
#endif
*/
}

